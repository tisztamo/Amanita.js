import Workered from "./workered.js"
import A from "./a.js"
import {delay} from "./utils/delay.js"

export const BareBonesAmanita = A(HTMLElement)
A.define("a-wrap", BareBonesAmanita)

class AScheduler extends Workered(HTMLElement) {
  workerSrc = ""
  spawnType() {
    return this.attr("server") === "true" ? "server" : "worker"
  }
}
A.define("a-scheduler", AScheduler)

function negate(val) {
  switch (typeof(val)) {
    case "number":
      return -val
    case "boolean":
      return !val
    case "string":
      if (!val || val === "false") return "true"
      return "false"
  }
  console.assert(false)
}

class AVar extends BareBonesAmanita {
  constructor() {
    super()
    for (const attrName of this.getAttributeNames()) {
      const raw = this.getAttribute(attrName)
      if (attrName == "value") {
        const type = this.attr("type")
        if (type === "number") { // 5 lines of code fully generated by github copilot...
          this.value = Number(raw)
        } else if (type === "object") {
          console.log(raw)
          this.value = JSON.parse(raw)
        } else {
          this.value = raw
        }
      } else {
        this[attrName] = raw
      }
    }
  }

  toggle = (attrName) => {
    const prop = attrName || "value"
    this.pub(prop, negate(this[prop]))
  }
}
A.define("a-var", AVar)

// Base class that project an input to itself
class Projector extends BareBonesAmanita {
  value = null
  _transform = null

  onConnect() {
    this.sub(this.attr("input"), this["[input]"])
    const transform = this.attr("transform")
    if (transform) {
      this.transform = this.val(transform) // TODO late binding
      console.assert(typeof this.transform === "function", `Transform '${transform}' does not resolve to a function.`, this)
    }
  }

  "[input]" = val => {
    const newVal = this.transform ? this.transform(val) : val
    if (newVal !== this.value) {
      this.update(newVal)
    }
  }
}

class ASwitch extends Projector {
  _subscription = null
  selectedChild = null

  constructor() {
    super()
    if (this.getAttribute("hide") === "remove") {
      this.templates = []
      const children = this.children
      for (let i = 0; i < children.length; i++) {
        children[i].setAttribute("_a-switch_idx", i)
        this.templates[i] = this.children[i].outerHTML
        if (i !== children.length - 1 || children[i].getAttribute("case") !== null) {
          children[i].outerHTML = this.standinHtmlFor(children[i])
        }
      }
    }
  }

  async update(value) {
    const children = this.children
    const valueStr = value.toString()
    let selected = null
    for (let i = 0; i < children.length; i++) {
      const child = children[i]
      const _case = child.getAttribute("case")
      console.assert(_case !== null || i === children.length - 1, "Default case (without case attr) must be the last child of <a-switch>", child)
      const isSelected = _case === valueStr || (!selected && _case == null && i === children.length - 1)
      await this.updateChild(child, isSelected)
      if (isSelected) selected = child
    }
    this._selectChild(selected)
  }

  standinHtmlFor(child) {
    const caseAttr = child.getAttribute("case")
    return `<template ${caseAttr ? `case="${caseAttr}"` : ""} _a-switch_idx="${child.getAttribute("_a-switch_idx")}"></template>`
  }

  async updateChild(child, isSelected) {
    const hideMode = this.getAttribute("hide") || "visibility" // display, visibility(default), remove, none. All others mean "none" for now
    if (hideMode === "visibility") {
      child.style.visibility = isSelected ? "visible" : "hidden"
    } else if (hideMode === "display") {
      if (isSelected) {
        child.style.removeProperty("display")
      } else {
        child.style.display = "none"
      }
    } else if (hideMode === "remove") {
      if (isSelected) {
        if (this.getAttribute("async") === "true") await delay(0)
        child.outerHTML = this.templates[Number(child.getAttribute("_a-switch_idx"))]
      } else {
        child.outerHTML = this.standinHtmlFor(child)
      }
    }
  }

  _selectChild(child) {
    if (this.selectedChild === child) return
    if (this.selectedChild && this.selectedChild._a) {
      this.selectedChild.off(this._subscription)
      this._subscription = null
    }
    this.selectedChild = child
    if (child && A.isA(child)) {
      this._subscription = child.on("value", this.forward)
    }
  }

  forward = (value) => this.pub(value)
}
A.define("a-switch", ASwitch)

// TODO publish value
// TODO convert to a directive?
// TODO does not support hide="remove"
// TODO do we need this?
class AIf extends Projector {
  update(value) {
    const hideMode = this.getAttribute("hide") || "visibility"
    const visible = value && value !== "false"
    if (hideMode === "visibility") {
      this.style.visibility = visible ? "visible" : "hidden"
    } else if (hideMode === "display") {
      this.style.display = visible ? "block" : "none"
    }
  }
}
A.define("a-if", AIf)

class AText extends Projector {
  update(value) {
    this.textContent = value.toString()
  }
}
A.define("a-text", AText)

class ARadio extends BareBonesAmanita {
  value = null // value attr of selectedEl
  selectedEl = null

  onConnect() {
    const passiveClasses = (this.attr("passive") || "").split(" ")
    const children = this.children
    for (let i = 0; i < children.length; i++) {
      const child = children[i]
      const selected = child.getAttribute("selected")
      if (selected !== null && selected !== "false") {
        this.select(child)
      } else {
        passiveClasses.forEach(passiveClass => {
          if (child.getAttribute("value")) {
            child.classList.add(passiveClass)
          }
        })
      }
    }
  }

  select(child) {
    const value = child.getAttribute("value")
    if (value === null) {
      console.assert(value, "No 'value' attribute is set for selected child")
      return // For production builds
    }
    if (value === this.value) return
    const activeClasses = (this.attr("active") || "").split(" ")
    const passiveClasses = (this.attr("passive") || "").split(" ")
    activeClasses.forEach(activeClass => {
      this.selectedEl && this.selectedEl.classList.remove(activeClass)
      child.classList.add(activeClass)
    })
    passiveClasses.forEach(passiveClass => {
      this.selectedEl && this.selectedEl.classList.add(passiveClass)
      child.classList.remove(passiveClass)
    })
    this.selectedEl = child
    this.pub("value", value)
  }

  "@click" = e => {
    const selected = e.target.closest("[value]")
    console.assert(selected && this.contains(selected), "No 'value' attribute is set for selected child") // possible an outer radio provides bad value
    this.select(selected)
  }
}
A.define("a-radio", ARadio)

// TODO publish parsed data as composite object + allow deep modification with reserialization
class AUrl extends BareBonesAmanita {
  constructor() {
    super()
    this.update(document.location)
  }

  onConnect() {
    queueMicrotask(() => {
      for (let i = 0; i < this.children.length; i++) {
        const child = this.children[i]
        if (A.isA(child)) {
          child.on("value", (value) => {
            if (value) {
              this.pub(value)
            }
          })
        }
      }
    })
    window.addEventListener('hashchange', () => {
      this.update(document.location)
    })
  }

  // TODO off onDisconnect

  update(location) {
    this.pub("route", location.hash.substring(1))
  }
}
A.define("a-url", AUrl)

class AMatch extends Projector {
  constructor() {
    super()
    this.match = new RegExp(this.attr("regexp"), this.attr("flags") || undefined)
    if (this.getAttribute("input") === null) this.setAttribute("input", "../route")
  }

  update(value) {
    const strVal = value.toString()
    const result = strVal.match(this.match)
    if (result) {
      this.pub("route", strVal.replace(this.match, ""))
      this.pub(result[1])
    } else {
      this.pub("route", "")
      this.pub(false)
    }
  }
}
A.define("a-match", AMatch)

// TODO do we really need this?
class AKeyboard extends BareBonesAmanita {
  onConnect() {
    document.addEventListener("keydown", this.onKeydown)
  }

  onDisconnect() {
    document.removeEventListener("keydown", this.onKeydown)
  }

  onKeydown = e => {
    const toggledChildren = this.querySelectorAll("[togglekey]")
    const {key, code} = e
    for (let i = 0; i < toggledChildren.length; i++) {
      const target = toggledChildren[i].getAttribute("togglekey")
      if (target === key || target === code) {
        toggledChildren[i].toggle()
      }
    }
    this.pub(code)
  }
}
A.define("a-keyboard", AKeyboard)
